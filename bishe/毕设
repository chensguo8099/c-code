    对于日志系统的整体设计，从网卡数据采集开始，我的最初设计构想是，让Go程序在Docker中运行抓包的过程（图.....），并且将抓取的数据以交易的方式写入至区块中。最初构想的缺点有以下几点：
（1）由于Go抓包程序所涉及的不仅是引入第三方gopacket包，涉及到如何在Docker容器中移植第三方包等环境问题，同时还要安装依赖包至容器中，比如pcap环境，pcap环境是Linux中tcpdump的基础，利用pcap环境，才能在gopacket中进行抓包，可见如果将Go抓包程序引入至Fabric自己的Docker容器中，最主要的是会面临复杂的环境配置。
（2）尽管已经实现第一步，即让Go程序能够抓取数据并且将抓取到的数据作为交易进行提案，但是Go抓包程序具有实时性，Go所抓取到的数据信息是实时返回的，而在往区块中写入是需要性能的，因为不及时的写入区块可能导致交易提案太多。实时的交易提案不一定带来更加流畅的区块链网络，反而可能因为Go抓包的实时性和Fabric平台的区块链提案、打包、验证的速度不匹配，导致当Go程序抓取信息并且返回时的速度到达一定yyyyyyyuuuuuu值后，可能会影响导致区块链网络直接瘫痪。（效率影响图-----）。
    
    因此对于上述缺点进行了改进，将Go抓包程序与Fabric的Docker环境分离开，Go负责抓取数据，并且Go将抓取到的包信息写入到一个名为log.txt的文件内（即就是增加一个写入硬盘这样的中间层过程），因为Fabric网络的低效和实时性差，可以让其与磁盘数据进行交互，对上述缺点也是一个弥补。因此智能合约在网卡信息采集模块中的作用实际上就是将log.txt文件中的抓包数据进行读取，还有就是对log.txt文件进行清空内容的功能。
    网卡信息的采集模块大体构想如上，接下来是用户自定义数据的操作模块的设计，用户自定义数据操作分为三种操作：
（1）向区块中写入用户自定义数据
（2）从区块中读出用户自定义数据
（3）删除区块中数据
    需要说明的是，这里区块中要写入的自定义数据指的是：字符串类型。比如某日有哪些规划日程、有什么读书笔记或者每日的感想等，均可记录在区块内。
    当向区块中写入这些数据后，如“hello  world!”，那么会标记哪年哪月哪日发表了该字串，当用户需要查询的时候只需要输入特定的年月日所组成的字符串即可。
    
    在对分布式日志系统进行设计时，具体的每一次日志录入（可以比作发起交易），都会被记录并且排序，多个交易记录会构成一个区块，再对区块进行连接，最终构成区块链。那么区块中的交易信息的存储实际上依靠的是状态数据库。
    Fabric的状态数据库其实包含了两个可选项，即LevelDB和CouchDB。但是LevelDB是嵌入至Peer中的默认key-value键值对状态数据库。CouchDB是可替代LevelDB的外部状态数据库，CouchDB数据库是被一个来自于IBM的工程师于2005年所研发出，它也是key-value键值对数据库，与LevelDB键值一样，LevelDB和CouchDB都支持核心链代码操作，它们都可按照key的范围进行查询，但是CouchDB相比于LevelDB，它更加适应于多种不同的复杂场景，能够在这些复杂场景下进行复杂的富查询。所以最终在日志系统中对用户的字符串数据存储选择存储在CouchDB当中。所以日志系统的整体架构设计为图3-2-XX。

3.2.2 Go抓包程序的设计
    Go抓包程序具体引入了go语言第三方包gopacket，gopacket包是google提供的Go语言第三方包，主要用于硬件检测和流量抓取，gopacket中使用了libpcap库，pcap是Linux命令tcpdump的基本依赖，因此使用Go提供的第三方包gopacket可以让我们很轻松的抓取网卡中的数据信息。
    Go抓包程序主要指定了log.txt的路径，然后将gopacket所抓取的网卡信息写入至文件log.txt中，伪代码如下!!!!!!!!!。



    代面中需要先打开指定网卡设备，这里指定的是本机名为wlp3s0的网卡，通过pcap.OpenLive获取设备对应的文件句柄handle，其中handle是一个*pcap.Handle类型的变量。只需要在代码中调用gopacket.NewPacketSource(handle, handle.LinkType())函数，与设备关联的文件句柄handle作为该函数的第一个参数，该函数返回包对象packetSource，通过遍历packetSource的Packets()方法来获取采集的信息，然后将字符串写入文件即可。
    接下来对抓取的包信息进行分析，Go抓包程序所抓取的包包括网络接口层、网际层、运输层、应用层等。本次模拟进入微软Bing网站，通过对网卡数据采集，发现应用层数据是用户发出去然后抓取到的，并未抓取到外界而来的有应用层数据的包。以下截取一段抓包的过程进行分析：
PACKET: 54 bytes, wire length 54 cap length 54 @ 2019-06-02 21:16:34.0664 +0800 CST
- Layer 1 (14 bytes) = Ethernet	{Contents=[..14..] Payload=[..40..] SrcMAC=72:ef:00:d4:8f:64 DstMAC=bc:30:7d:97:c6:46 EthernetType=IPv4 Length=0}
- Layer 2 (20 bytes) = IPv4	{Contents=[..20..] Payload=[..20..] Version=4 IHL=5 TOS=0 Length=40 Id=21101 Flags= FragOffset=0 TTL=113 Protocol=TCP Checksum=36236 SrcIP=202.89.233.101 DstIP=172.20.10.3 Options=[] Padding=[]}
- Layer 3 (20 bytes) = TCP	{Contents=[..20..] Payload=[] SrcPort=443(https) DstPort=47256 Seq=3161831994 Ack=2092010564 DataOffset=5 FIN=false SYN=false RST=false PSH=false ACK=true URG=false ECE=false CWR=false NS=false Window=1023 Checksum=2053 Urgent=0 Options=[] Padding=[]}

    由PACKET后字节数可知这一个包经过三层封装后的大小总共为54bytes，其中第一层数据包为14字节，第二层和第三层均为20字节。上面还记录了抓取包的时间为2019-06-02。然后在往后则是Layer1、Layer2、Layer3表示第一层、第二层、第三层。
    其中第一层即网络接口层，上面显示为以太网（Ethernet），并且标注了源MAC地址和目的MAC地址，其中目的MAC地址即为本主机的MAC地址（图。。），还说名了以太网的类型是IPv4类型。
    接着是第二层，即网络层（或IP层），其中说到该网络层用到的是IPv4协议，IHL（Internet Header Length），即Internet头部长度为5位。TOS是QOS的一种标记机制。可以看到第二层协议（Protocol）使用的是TCP协议，并且数据包标记了源IP地址和目的IP地址，可以在网页查询源IP地址所属地，根据查询，确定源IP地址202.89.233.101为北京微软公司（图。。。。。）。
    最后说明第三层抓包的信息，抓取的是一个TCP包信息，其标记为TCP，即传输层TCP协议，包数据说明了源端口通过443（https指定端口）发出到目的端口47256，目的端口即本机Linux内核随机生成的空闲端口。因为采用TCP协议，所以包中还有同步、确认等信息。

3.2.3 用户自定义日志设计
    已经说到，用户自定义的日志主要可以是每日感想、行程规划亦或是读书笔记等等。那么该日志的功能实际上就是对字符串的写入，主要的难点在于如何组织数据，所以本节主要讨论如何设计日志系统的日志存放，讨论如何在CouchDB这样的key-value数据库中组织数据。
    因为CouchDB的数据库类型，实际上数据是以key-value键值对的方式存放至CouchDB数据库当中的，所以具体的每个key都对应是唯一的标识，无法重复出现相同的key对应的多条key-value键值对，最初设想将key可标记起始为1，value则用于存放用户要自定义的每日感想、行程规划、读书笔记等字串，随着用户写入的value数量的增加，key值依次累加即可，但是这样设计的时候，在进行查询时会存在以下缺点（缺点图。。。。）：
（1）随着数据量的增大，简单的key-value查询遍历大量数据效率较低。
（2）用户并不知道其每次发表的行程规划、字符串记录的读书笔记、每日感想等日志对应的key是多少，key值不能直观的引起用户的感知，就比如IP不能像域名一样使用户更加深刻的记忆。
    因此对于以上弊端，可以修改key-value的设计（改进图。。。），为了用key标识唯一，具体设计是将年月日拼接成字符串作为key进行唯一标识每天。但是如果将key标识为年月日的组合，那么value必然不能是字符串，因为如果value是字符串，则结果就是每日仅能发送一条用户自定义的数据，当发送第二条或者再更多条，均是对前面的value的覆盖，因此对于key-value键值对存储的设计是将年月日拼接字符串作为key，然后value存放一个map，map结构中的key作为起始为1进行累加，map结构中的value这存放具体的用户自定义数据（规划日程、读书笔记、每日感想等），这样每年每月每日即可对应多条数据，并且用户对年月日记录更加清晰。









本文中还有需要改进的地方，比如在对Go抓包程序的设计是将其与Fabric的Docker容器分离开，将Go抓包信息写入log.txt（磁盘中），其目的在于解决抓包与Fabric区块链网络的速度不匹配问题，因此增加了将数据写入磁盘这样的操作，但是改进指出在于可以将Go抓取的信息写入在Redis这样的缓存数据库中，这不但没有影响到Go抓包程序的实时性，由于我们对内存的访问是快于磁盘的，所以在Fabric区块链网络获取交易数据并打包至区块的过程中，也使得Fabric网络的效率最大化。
